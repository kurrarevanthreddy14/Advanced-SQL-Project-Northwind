# Advanced SQL Analysis of the Northwind Database

## Project Objective
This project demonstrates proficiency in advanced SQL by querying the classic Northwind relational database. The goal was to extract actionable business insights by answering a wide range of business questions related to customers, employees, orders, and products. The queries showcase a range of SQL techniques including multi-table JOINs, LEFT JOINs, aggregate functions with GROUP BY and HAVING, and conditional logic with CASE statements.

## Dataset
This analysis uses the standard **Northwind** sample database, which models the sales data for a fictional specialty foods import/export company called "Northwind Traders." The database includes interconnected tables for `Customers`, `Orders`, `Employees`, `Products`, `Suppliers`, and more.

## Tools Used
* **Database:** SQLite
* **Querying Tool:** DB Browser for SQLite

---

## Table of Contents
1.  [Customer and Employee per Order](#1-customer-and-employee-per-order)
2.  [Products from a Specific Supplier](#2-products-from-a-specific-supplier)
3.  [Late Shipments](#3-late-shipments)
4.  [Total Cost per Order](#4-total-cost-per-order)
5.  [Customers with No Orders](#5-customers-with-no-orders)
6.  [Top-Performing Employees by Order Volume](#6-top-performing-employees-by-order-volume)
7.  [Overall Order Date Range](#7-overall-order-date-range)
8.  [Quarterly Order Summary](#8-quarterly-order-summary)

---

## SQL Analysis: Business Questions & Queries

This project answers eight key business questions, moving from basic joins to more complex aggregations and conditional logic.

### 1. Customer and Employee per Order
* **Objective:** To create a consolidated view of every order for reporting purposes.
* **Technique:** A three-table `INNER JOIN` is used to link the `Orders`, `Customers`, and `Employees` tables on their respective ID keys.

```sql
SELECT
    o.OrderID,
    c.CompanyName,
    e.FirstName,
    e.LastName
FROM
    Orders o
INNER JOIN
    Customers c ON o.CustomerID = c.CustomerID
INNER JOIN
    Employees e ON o.EmployeeID = e.EmployeeID;
```
* **Result Sample:**
| OrderID | CompanyName | FirstName | LastName |
|:---|:---|:---|:---|
| 10248 | Vins et alcools Chevalier | Steven | Buchanan |
| 10249 | Toms Spezialitäten | Michael | Suyama |
| ... | ... | ... | ... |


### 2. Products from a Specific Supplier
* **Objective:** To filter products based on a specific supplier.
* **Technique:** An `INNER JOIN` connects the `Products` and `Suppliers` tables, with a `WHERE` clause to filter by company name.

```sql
SELECT
    p.ProductID,
    s.CompanyName,
    p.ProductName
FROM
    Products p
INNER JOIN
    Suppliers s ON p.SupplierID = s.SupplierID
WHERE
    s.CompanyName = 'Exotic Liquids';
```
* **Result Sample:**
| ProductID | CompanyName | ProductName |
|:---|:---|:---|
| 1 | Exotic Liquids | Chai |
| 2 | Exotic Liquids | Chang |
| 3 | Exotic Liquids | Aniseed Syrup |


### 3. Late Shipments
* **Objective:** To identify operational inefficiencies in the shipping process.
* **Technique:** A simple date comparison in the `WHERE` clause is used to find all orders shipped after their required date.

```sql
SELECT
    OrderID,
    RequiredDate,
    ShippedDate
FROM
    Orders
WHERE
    ShippedDate > RequiredDate;
```
* **Result:**
*(The query ran successfully and returned no results, indicating that there were no late orders in this dataset—a valid finding.)*


### 4. Total Cost per Order
* **Objective:** To calculate the revenue generated by each order, including any discounts.
* **Technique:** This query joins multiple tables and performs a `SUM` on a calculated column (`UnitPrice * Quantity * (1 - Discount)`).

```sql
SELECT
    o.OrderID,
    SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS TotalOrderCost
FROM
    Orders o
INNER JOIN
    OrderDetails od ON o.OrderID = od.OrderID
GROUP BY
    o.OrderID
ORDER BY
    TotalOrderCost DESC;
```
* **Result Sample:**
| OrderID | TotalOrderCost |
|:---|:---|
| 10865 | 16387.5 |
| 10981 | 15810.0 |
| ... | ... |


### 5. Customers with No Orders
* **Objective:** To identify potential leads or inactive customers.
* **Technique:** This query uses a `LEFT JOIN` to find all customers who do not have a corresponding entry in the `Orders` table.

```sql
SELECT
    c.CustomerID,
    c.CompanyName
FROM
    Customers c
LEFT JOIN
    Orders o ON c.CustomerID = o.CustomerID
WHERE
    o.OrderID IS NULL;
```
* **Result Sample:**
| CustomerID | CompanyName |
|:---|:---|
| FISSA | FISSA Fabrica Inter. Salchichas S.A. |
| PARIS | Paris spécialités |
| ... | ... |


### 6. Top-Performing Employees by Order Volume
* **Objective:** To identify top-performing employees based on the volume of orders processed (in this case, those with over 100 orders).
* **Technique:** This query uses `COUNT` to aggregate the number of orders and the `HAVING` clause to filter the results *after* grouping.

```sql
SELECT
    e.FirstName,
    e.LastName,
    COUNT(o.OrderID) AS NumberOfOrders
FROM
    Employees e
INNER JOIN
    Orders o ON e.EmployeeID = o.EmployeeID
GROUP BY
    e.EmployeeID, e.FirstName, e.LastName
HAVING
    COUNT(o.OrderID) > 100
ORDER BY
    NumberOfOrders DESC;
```
* **Result Sample:**
| FirstName | LastName | NumberOfOrders |
|:---|:---|:---|
| Margaret | Peacock | 156 |
| Janet | Leverling | 127 |
| ... | ... | ... |


### 7. Overall Order Date Range
* **Objective:** An exploratory query to understand the time span of the dataset.
* **Technique:** `MIN()` and `MAX()` aggregate functions are used on the `OrderDate` column.

```sql
SELECT
    MIN(OrderDate) AS FirstOrder,
    MAX(OrderDate) AS LastOrder
FROM
    Orders;
```
* **Result:**
| FirstOrder | LastOrder |
|:---|:---|
| 2016-07-04 | 2018-05-06 |


### 8. Quarterly Order Summary
* **Objective:** To analyze business activity and identify trends over time.
* **Technique:** This query uses a `CASE` statement to create custom groupings for each fiscal quarter and year.

```sql
SELECT
    CASE
        WHEN strftime('%m', OrderDate) IN ('01', '02', '03') THEN strftime('%Y', OrderDate) || '-Q1'
        WHEN strftime('%m', OrderDate) IN ('04', '05', '06') THEN strftime('%Y', OrderDate) || '-Q2'
        WHEN strftime('%m', OrderDate) IN ('07', '08', '09') THEN strftime('%Y', OrderDate) || '-Q3'
        WHEN strftime('%m', OrderDate) IN ('10', '11', '12') THEN strftime('%Y', OrderDate) || '-Q4'
    END AS OrderQuarter,
    COUNT(OrderID) AS NumberOfOrders
FROM
    Orders
GROUP
´´´

